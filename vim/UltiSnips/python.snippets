global !p

# ~/.vim/pythonx/global_helpers.py
from global_helpers import (
    closing_character,
    maybe_comma
)

# ~/.vim/pythonx/python_helpers.py
from python_helpers import (
    class_name
)

def initialize_args(tabstop, snip):
    if not tabstop:
        snip.rv = ""
        return

    args = [string.strip() for string in tabstop.split(",") if string]
    snip.shift(2)
    for arg in args:
        snip += snip.mkline("", indent="")
        snip.rv += f"self.{arg} = {arg}"

def comprehension_opening(comprehension_type):
    match comprehension_type:
        case "list":
            return "["
        case "generator":
            return "("
        case _:
            return "{"

endglobal

snippet class "Python class" b
class ${1:`!p snip.rv = class_name(snip)`}${2:(${3:object})}:
    ${4:"""
    ${5:TODO: Docstring for $1.}
    """

    }${6:def __init__(self$7):`!p initialize_args(t[7], snip)`}$0
endsnippet

# REF for multiple negative lookbehinds of differing lengths: https://stackoverflow.com/a/40617321/567863
snippet "(?<!dictionary )(?<!generator )(?<!list )(?<!set )comprehension" "choice of comprehension type" rw
${1|list comprehension,dictionary comprehension,set comprehension,generator comprehension|}$0
endsnippet

snippet def "decide what kind of function or method to create" b
def ${1|function,instance method,class method,static method|}$0
endsnippet

snippet "def (function|instance(?: method)?)" "function or instance method" rb
`!p
def_type = match.group(1)
maybe_self = "self" if "instance" in def_type else ""
`def ${1:name}(${2:`!p snip.rv = maybe_self`}`!p snip.rv = maybe_comma(t[2], t[3])`${3:args}):
    ${4:"""
    ${5:TODO: Docstring for $1.}
    """
    }$0
endsnippet

snippet "def (class(?: method)?|static(?: method)?)" "class or static method" rb
`!p
def_type = match.group(1)
decorator_name = "class" if "class" in def_type else "static"
maybe_cls = "cls" if "class" in def_type else ""
`@`!p snip.rv = decorator_name`method
def ${1:name}(${2:`!p snip.rv = maybe_cls`}`!p snip.rv = maybe_comma(t[2], t[3])`${3:args}):
    ${4:"""
    ${5:TODO: Docstring for $1.}
    """
    }$0
endsnippet

snippet "else if" "else if condition" b
elif ${1:condition}:
    ${2:${VISUAL:# do something}}$0
endsnippet

snippet false "False" w
False$0
endsnippet

snippet for "for statement" b
for ${2:element} in ${1:iterable}:
    ${3:${VISUAL:# do something}}${4:
else:
    ${5:# nothing found in $1}}$0
endsnippet

snippet from "Python import from statement" b
from ${1:module} import ${2:(
    }${3:function}${4: as ${5:alias}}$0
`!p snip.rv = closing_character(t[2].strip())`
endsnippet

snippet if "if statement" b
if ${1:condition}:
    ${2:${VISUAL:# do something}}${3:
else:
    ${4:# do something else}}$0
endsnippet

snippet import "Python single import statement" b
import ${1:module}${2: as ${3:alias}}$0
endsnippet

snippet lambda "Lambda expression" w
lambda ${1:params}: $2$0
endsnippet

snippet "(list|dictionary|set|generator) comprehension" "comprehension" rw
${1:`!p snip.rv = comprehension_opening(match.group(1))`}${5:expression} for ${4:item} in ${2:iterable}$3${6: if ${7:condition}}`!p snip.rv = closing_character(t[1])`$0
endsnippet

snippet "mod(ulo)?" "% modulo" rw
% ${1:number}${2: == ${3:0}}$0
endsnippet

snippet none "None" w
None$0
endsnippet

snippet return "return statement" b
return ${1:value}$0
endsnippet

snippet true "True" w
True$0
endsnippet

snippet "(ternary|conditional)" "Conditional expression (ternary)" rw
${2:True} if ${1:condition} else ${3:False}$0
endsnippet

snippet yield "yield statement" b
yield ${1:from }${2:expression}$0
endsnippet
