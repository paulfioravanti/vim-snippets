global !p

import re
from UltiSnips import vim_helper

_HTML_KEYWORDS = [
    "article",
    "audio",
    "body",
    "button",
    "code",
    "div",
    "em",
    "figcaption",
    "figure(?: caption)?",
    "footer",
    "form",
    "h[1-6]",
    "head",
    "html",
    "k(?:ey)?b(?:oar)?d",
    "li(?:st item)?",
    "main",
    "nav",
    "ol",
    "ordered list",
    "p(?:re)?",
    "rt",
    "ruby(?: text)?",
    "samp(?:le)?",
    "section",
    "select",
    "span",
    "strong",
    "style",
    "table(?: data| footer| head| row)?",
    "tbody",
    "td",
    "text\s?area",
    "tf",
    "th(?:ead)?",
    "title",
    "tr",
    "ul",
    "unordered list",
    "var",
    "video"
]
_HTML_KEYWORD = re.compile(rf"\b({'|'.join(_HTML_KEYWORDS)})\b")

_IDS = re.compile(r"(?<=#)[^\.#]+") # #some-id
_CLASSES = re.compile(r"(?<=\.)[^\.#]+") # .some-class
_MULTILINE = "multi-line"

# Bridging list of English words/phrases to HTML tag names
_TAG_NAMES = {
    "figure caption": "figcaption",
    "keyboard": "kbd",
    "list item": "li",
    "ordered list": "ol",
    "ruby text": "rt",
    "sample": "samp",
    "table data": "td",
    "table footer": "tfoot",
    "table head": "thead",
    "table row": "tr",
    "text area": "textarea",
    "unordered list": "ul"
}

def build_tag_with_attributes(snip, match):
    tag = text_to_tag(match)
    tag_type = match.group(3)
    output = f"<{tag}"

    if (specified_attributes := tag_args(match)):
        id_default_text = _attribute_text(_IDS, specified_attributes)
        class_default_text = _attribute_text(_CLASSES, specified_attributes)
    else:
        id_default_text = "id"
        class_default_text = "classes"

    # NOTE: Although a tag with attributes probably doesn't need this wrapping
    # $1 tabstop, without it, the snippet spacing is borked.
    output += "${1:"

    if specified_attributes:
        if id_default_text:
            output += f" id=\"{id_default_text}\""

        if class_default_text:
            output += f" {class_attribute_name()}=\"{class_default_text}\""
    else:
        output += f"${{2: id=\"${{3:{id_default_text}}}\"}}"
        output += f"${{4: ${{5:{class_attribute_name()}}}=\"${{6:{class_default_text}}}\"}}"

    output += "}$7>"

    if tag_type == _MULTILINE:
        output += "\n  "

    output += "${8:${VISUAL}}"

    if tag_type == _MULTILINE:
        output += "\n"

    output += f"</{tag}>"

    snip.expand_anon(output)

def class_attribute_name():
    # This handling needed for React.
    # NOTE: snip.ft not available during pre_expand/post_jump, which is when
    # this function is used. See SnippetUtilForAction class in Ultisnips
    # codebase to show that it only responds to `expand_anon`:
    # https://github.com/SirVer/ultisnips/blob/master/pythonx/UltiSnips/text_objects/python_code.py
    return "className" if vim_helper.eval("&filetype") == "javascript" else "class"

def tag_args(match):
    return match.group(2) or ""

def text_to_tag(match):
    text = match.group(1)
    return _TAG_NAMES.get(text, text)

def _attribute_text(attribute_type, attributes):
    return " ".join(re.findall(attribute_type, attributes))

endglobal

context "re.match(_HTML_KEYWORD, match.group(1))"
snippet "\b([a-z1-6\s]+)([#\.][^\s]+)?" "HTML tag single-line or multi-line choice" r
`!p snip.rv = text_to_tag(match) + tag_args(match)` ${1|multi-line,single-line|}$0
endsnippet

context "re.match(_HTML_KEYWORD, match.group(1))"
post_jump "build_tag_with_attributes(snip, match)"
snippet "\b([a-z1-6\s]+)([#\.][^\s]+)? (multi-line)" "HTML tag multi-line" r
$0
endsnippet

context "re.match(_HTML_KEYWORD, match.group(1))"
post_jump "build_tag_with_attributes(snip, match)"
snippet "\b([a-z1-6\s]+)([#\.][^\s]+)? (single-line)" "HTML tag single-line" r
$0
endsnippet

snippet iframe "HTML iframe tag" i
<iframe src="${1:src}">$0</iframe>
endsnippet

snippet img "HTML img tag" i
<img src="${1:src}"${2: alt="${3:alt}"} />$0
endsnippet

snippet input "HTML input tag of type 'text'" b
<input type="text"${1:${2: id="${3:id}"}${4: class="${5:class}"}${6: name="${7:name}"}${8: value="${9:value}"}} />$0
endsnippet

snippet "\binput (button|checkbox|color|datetime-local|email|file|hidden|month|password|radio|reset|search|submit|text|time|url|week)" "HTML input tag of (type) with id, class, name, value" r
`!p
input_type = match.group(1)
`<input type="`!p snip.rv = input_type`"${1:${2: id="${3:id}"}${4: class="${5:class}"}${6: name="${7:name}"}${8: value="${9:value}"}} />$0
endsnippet

snippet "\binput (date|number|range)" "HTML input tag of (type) with id, name, min, max" r
`!p
input_type = match.group(1)
`<input type="`!p snip.rv = input_type`"${1:${2: id="${3:id}"}${4: class="${5:class}"}${6: name="${7:name}"}${8: value="${9:value}"}${10: min="${11:min}"}${12: max="${13:max}"}} />$0
endsnippet

snippet "input tel" "HTML input tag of telephone number type" b
<input type="tel"${1:${2: id="${3:id}"}${4: class="${5:class}"}${6: name="${7:name}"}${8: value="${9:value}"}${10: pattern="${11:pattern}"}} />$0
endsnippet

snippet label "Inline label tag" i
<label ${1:for="${2:input-id}}>${3:${VISUAL}}</label>$0
endsnippet

snippet "(link|anchor|a tag)" "HTML <a> tag" r
<a href="${1:url}"${2: target="${3|_blank,_parent,_top|}"}>
  ${4:${VISUAL:text}}
</a>$0
endsnippet

snippet "(link|anchor) (mail|email)" "HTML <a> tag link to telephone number" r
<a href="mailto:${1:${VISUAL:address}}">${2:$1}</a>$0
endsnippet

snippet "(link|anchor) phone" "HTML <a> tag link to telephone number" r
<a href="tel:${1:${VISUAL:number}}">${2:$1}</a>$0
endsnippet

snippet method "<form> method attribute" i
method="${1|post,get|}"$0
endsnippet

snippet option "HTML option tag" i
<option value="${1:value}">${2:text}</option>$0
endsnippet

snippet source "HTML source tag" i
<source src="${1:url}" type="${2:type}" />$0
endsnippet

snippet target "<form> target attribute" i
target="${1|_blank,_parent,_top|}"$0
endsnippet
