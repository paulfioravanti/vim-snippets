global !p

# ~/.vim/pythonx/global_helpers.py
from global_helpers import (
    closing_character
)

# ~/.vim/pythonx/javascript_helpers.py
from javascript_helpers import (
    maybe_spaces
)

endglobal

snippet Array "Array() constructor" i
Array(${1:elements or length})$0
endsnippet

snippet "[Aa]rray[\. ]from\s?([Aa]sync)?" "Array.from/fromAsync()" r
`!p maybeAsync = "Async" if match.group(1) else ""
`Array.from`!p snip.rv = maybeAsync`(${1:${VISUAL:arrayLike}}${2:${3:, ${4:mapFn}}${5:, ${6:thisArg}}})$0
endsnippet

snippet "([Aa]rray\.)?is\s?[Aa]rray" "Array.isArray()" r
Array.isArray(${1:value})$0
endsnippet

snippet "[Aa]rray[\. ]of" "Array.of()" r
Array.of(${1:${2:element1}${3:, ${4:element2}}$5})$0
endsnippet

# NOTE: Negative look behind for "ordered" due to conflicts with HTML
# "ordered list" (<ol>) tag trigger word.
context "snip.visual_text"
snippet "(?<!ordered )(?<!is )(?<!is)(array|list|\[\])" "Literal array/list with potential spread" r
[${1:...}${2:${VISUAL}}$3]$0
endsnippet

snippet "(?<!ordered )(?<!is )(?<!is)(array|list|\[\])" "Literal array/list" r
[$1]$0
endsnippet

snippet .fill "Array.prototype.fill(value, start, end)" i
.fill(${1:value}${2:, ${3:start}${4:, ${5:end}}})$0
endsnippet

snippet .join "Array.prototype.join(separator)" i
.join(${1:"${2:,}"})$0
endsnippet

snippet "(?<!Object).keys" "Array.prototype.keys()" r
.keys()$0
endsnippet

snippet .map "Array.prototype.map(callbackFn, thisArg)" i
.map(${3:${4:(}${5:x}`!p snip.rv = closing_character(t[4])` => ${6:\{}$7`!p snip.rv = maybe_spaces(t[6]) + closing_character(t[6])`}${1:, ${2:thisArg}})$0
endsnippet

snippet .push "Array.prototype.push()" i
.push(${1:${2:element1}${3:, ${4:element2}}})$0
endsnippet

snippet .reduce "Array.prototype.reduce(callbackFn, initialValue)" i
.reduce(${2:(${3:acc}, ${4:currentValue}) => ${5:\{}$6`!p snip.rv = maybe_spaces(t[5]) + closing_character(t[5])`}, ${1:initialValue})$0
endsnippet

snippet .reverse "Array.prototype.reverse()" i
.reverse()$0
endsnippet

snippet .slice "(Array|String).prototype.slice(indexStart, indexEnd)" i
.slice(${1:${2:indexStart}${3:, ${4:indexEnd}}})$0
endsnippet
